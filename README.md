# Just Omok  

Angular를 공부하기위해 진행한 프로젝트이다.
<br>
유저간의 통신은 socket.io 를 사용하여 구현했고 서버에서 클라이언트를 기억하기 위한 방법으로는 간단하게 JWT를 사용했다.
<br>

### 구조

![jom_structure]()

<br>
그림상엔 컴포넌트가 5개지만 TopNav와 Footer는 자리만 차지하고 사실상 아무기능도 안하기 때문에 주로 일하는 컴포넌트는 Board, Chat, Modal 3개이다.  <br>
<br>

### Service

앱에서 사용되는 서비스에 대해서만 설명하면 앱을 전체적으로 파악하는데 충분하다고 생각하기 때문에 서비스만 알아본다  <br>
<br>
앱에서 사용되는 서비스중 내가 직접 작성한건 소켓 통신을 다루는 socket.service.ts 하나밖에 없다.  <br>
socket.io를 Angular에 맞게 포팅한 라이브러리인 ngx-socket-io 라는걸 사용했다.  <br>
<br>

![jom_socketEvent]()

각각의 이벤트를 설명하자면 다음과 같다. <br>

> register & token  <br>

맨 처음 사이트에 접속하게 되면 닉네임을 묻는 모달창이 뜬다.  <br>
닉네임이 입력되면 register 이벤트를 발송하는데 이에 대한 답장으로 서버는 token 이벤트에 JWT 토큰을 담아서 보내준다.  <br>
클라이언트는 JWT 토큰을 받아서 로컬스토리지에 저장한다.  <br>
<br>
이후 사용자의 모든 요청에는 이 토큰을 같이 보내게 되며, 서버는 토큰을 검증한뒤 올바른 토큰일 경우에만 답신을 한다. 검증에 실패할경우 그냥 무시한다.
딱히 토큰의 사용기한이라던가 refresh 관련 구현은 없다. 그냥 받아서 영원히(사용자가 직접 지우지 않는한) 저장한다.  <br>
<br>

> queueStart & queueStop  <br>

닉네임을 등록한다음엔 큐를 돌리는 모달창이 뜬다.  <br>
게임시작! 버튼을 누르면 queueStart를 발송하며, 서버는 사용자의 소켓 아이디를 대기자큐에 추가한다.  <br>
서버의 대기자큐는 힙으로 구현했는데 자세한 내용은 밑에서 더 설명하겠다.  <br>
<br>
게임시작! 버튼을 또 누르면 queueStop을 발송하며, 서버는 사용자의 소켓 아이디를 '닷지한사람' 큐에 추가한다.  <br>
'닷지한사람' 큐 역시 힙으로 구현되어있다.

> disconnect  <br>

사용자가 브라우져를 그냥 꺼버리거나 하면 disconnect 이벤트가 발생한다.  <br>
이 경우 케이스가 두갈래로 나뉘는데  <br>
<br>
1. 게임은 아직 시작하지 않았지만 큐를 돌리던 중이었다면 '닷지한사람' 큐에 해당 소켓의 아이디를 추가한다.  <br>
2. 게임이 진행되던 도중이면 상대방에게 '당신이 이겼다' 라는 이벤트를 보낸다. 이걸 받은 상대방 클라이언트는 "상대방이 탈주했습니다" 라는 메세지와 함께 승리했다는 모달을 띄운다.  <br>
<br>
그리고 그림엔 안나와 있지만 큐를 돌리던중도 아니고 게임을 하던중도 아니라면 그냥 아무동작도 하지 않는다.  <br>

> put  <br>

오목판의 돌을 놓을때 발생하는 이벤트이다.  <br>
A와 B가 게임을 하는데, A 차례가 되서 A가 오목판에 수를 두면 A의 클라이언트는 해당 자리에 자신의 돌(파란색돌)을 놓은다음 put 이벤트를 발송한다.  <br>
서버는 이를 수신한뒤 그대로 상대편인 B에게 put 을 보내준다.  <br>
B의 클라이언트가 put을 수신받으면 해당위치에 상대편의 돌(빨간색돌)을 놓는다.  <br>

> passTurn & getTurn  <br>

put 과 같다. 본인 차례가 되서 오목판에 수를 두면 put 이벤트 말고도 passTurn을 같이 발송한다.  <br>
getTurn을 수신받은 상대방은 이제 본인의 수를 둘수 있다.  <br>

> win & gameOver  <br>

한 수를 둘때마다 본인이 게임이 이겼는지 졌는지 체크하게 되는데 이겼을경우 win을 발송한다.  <br>
이를 수신받은 서버는 양 클라이언트에 gameOver를 발송하는데, 여기에는 승리인지 패배인지 알려주는 데이터도 같이 보내진다.   <br>
<br>  
엄밀히 말하면 어떤 못된 사용자가 직접 클라이언트 소스코드를 조작해서 win 이벤트를 보내버리면 그 자리에서 그냥 이겨버리는 치팅을 시도 할 가능성이 있긴 하나, 어짜피 많이 이긴다고 보상이 있는것도 아니고 그런 실력자가 이런 조그만 토이프로젝트까지 와서 그런일을 벌이진 않을거라고 생각되기 때문에 관련 대응은 생략한다.  <br>
<br>
경기의 승패를 서버가 아닌 클라이언트측에서 처리한다는 점도 같은 맥락에서 그냥 넘어가기로 했다.  <br>

> chat  <br>

말 그대로 채팅 이벤트이다.  <br>
클라이언트는 나의 메세지는 ui에 직접 그리고 상대방의 메세지만 chat이벤트로 수신받아 ui에 그린다.  <br>

> matched  <br>

그림에는 안나왔지만 matched 이벤트가 있다.  <br>
게임이 잡히고 상대방이 정해지면 서버에서 클라이언트로 matched가 발송되며, matched를 수신받은 클라이언트는 큐를 잡고있는 상태인지 아닌지를 표현하는 'isQueueing' 프로퍼티를 true에서 false로 바꾼다.  <br>


### Extra Freature  

###### 대기자큐와 닷지큐

![waitQ_dodgeQ]()

1:1 게임이기 때문에 그림과 같이 복잡한 구조의 자료구조들은 사실 필요가 없다. 그냥 '대기자' 변수 하나만 둔다음  <br>
1. 사용자 A가 게임시작! 버튼을 누르면 A의 소켓 아이디를 '대기자' 변수에 할당한다.  <br>
2. 이후 사용자 B가 게임시작! 버튼을 누르면 A와 B를 매치시키고 '대기자' 변수에는 null 을 할당해서 비운다.  <br>
<br>
이 두가지 과정을 반복하기만 하면 충분하다.  <br>
하지만 실제 서비스에서는 어떻게 꼬일지 모르기 때문에 좀더 넉넉하게 처리할수 있게끔 큐를 사용했다.  <br>
<br>
과정은 다음과 같다.
일단 소켓이 서버와 처음 연결되면 서버는  Date.now() 로 해당 소켓에 타임스탬프를 할당한다.  <br>
그림상에 보이는 숫자가 바로 이 타임스탬프이며, 어떤 사용자가 게임시작! 을 누르면 이 큐에서 하나 빼서 매치시키거나 혹은 큐가 비었을경우엔 큐에 사용자의 아이디를 추가하는 방식이다.   <br>
<br>
문제는 큐를 돌리는 중에 닷지를 했을경우이다.  <br>
사용자가 의도적으로 닷지하지 않았더라도 브라우져가 그냥 꺼지거나 하는 돌발상황은 충분히 있을 수 있다.  <br>
이를 처리하기위해 '닷지큐' 가 필요하다.  <br>
위의 '소켓 이벤트' 항목에서도 설명했듯이 사용자가 큐잡기를 중단하거나 연결이 끊기면 닷지큐에 해당 소켓의 아이디가 추가된다.  <br>
어떤 사용자가 게임시작! 버튼을 눌러서 큐를 잡기 시작한다. 그럼 서버는 대기자 큐에서 플레이어를 하나를 꺼내는데, 이 플레이어의 타임스탬프가 닷지큐 루트의 타임스탬프와 같다면 얘는 상쇄되고 매치시키지 않는다. 이미 닷지한 플레이어기 때문이다.  <br>
<br>
그림상에는 설명을 위해 내용물이 주렁주렁 달려있는걸로 묘사했지만 실제 서버에서는 '큐에 내용물이 1개만 있거나' 혹은 '큐가 비었거나' 두가지 상태밖에 없다. 위에서 말했듯이, 애초에 이론상으론 변수 하나만으로 충분하기 때문이다.  <br>

